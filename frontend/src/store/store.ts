// store/store.ts - Complete Enhanced Store with Narrative Intelligence
// This represents the full evolution from basic story organization to intelligent narrative generation

import { create } from "zustand"
import { immer } from "zustand/middleware/immer"
import { subscribeWithSelector } from "zustand/middleware"
import { v4 as uuidv4 } from "uuid"

// Import existing API services that your application already uses
import { 
  branchService, 
  analyticsService, 
  healthService, 
  BranchOption, 
  getErrorMessage,
  APIError 
} from '@/lib/api'

// Import the enhanced graph analysis functionality we built earlier
import { 
  analyzeStoryStructure as analyzeStoryGraph, 
  getLinearStoryFromBranch, 
  exportAllBranches as exportAllStoryBranches,
  StoryStructure,
  StoryBranch 
} from '@/lib/story-graph'

// Import the new narrative intelligence engine that understands story flow
import { 
  narrativeEngine, 
  NarrativeContext, 
  GeneratedStory 
} from '@/lib/narrative-intelligence'

// Enhanced StoryNode interface that includes AI generation capabilities
// This builds on your existing node structure while adding narrative intelligence features
export interface StoryNode {
  id: string
  content: string
  title: string
  position: { x: number; y: number }
  connections: string[]
  status: "draft" | "written" | "suggestion" | "ai-generated"  // Added AI-generated status
  createdAt: Date
  updatedAt: Date
  wordCount: number
  characterCount: number
  tags: string[]
  notes: string
  
  // NEW: Narrative Intelligence metadata
  // These fields help track how and when AI-generated content was created
  generationContext?: string        // What story context was used to generate this scene
  isAutoGenerated?: boolean        // Whether this content was created by AI
  lastRegeneratedAt?: Date         // When this scene was last automatically updated
  narrativeDependencies?: string[] // Which scenes this one depends on for context
}

// Enhanced StoryProject interface with AI generation preferences
// This allows users to control how narrative intelligence works for each project
export interface StoryProject {
  id: string
  title: string
  description: string
  createdAt: Date
  updatedAt: Date
  genre: string
  targetWordCount?: number
  
  // NEW: Narrative Intelligence settings
  // These settings control how the AI generates content for this specific project
  autoGenerateContent?: boolean     // Whether to automatically generate content when scenes are connected
  aiWritingStyle?: string          // Preferred AI writing style (adaptive, formal, casual, etc.)
  narrativeComplexity?: 'simple' | 'moderate' | 'complex'  // How sophisticated the AI writing should be
  branchIsolation?: boolean        // Whether branches should be kept completely separate (default: true)
  contextDepth?: number           // How many previous scenes to include in context (default: all)
}

// Enhanced EditorSettings interface (your existing editor preferences)
export interface EditorSettings {
  fontSize: number
  fontFamily: "serif" | "sans-serif" | "mono"
  lineHeight: number
  autoSave: boolean
  autoSaveDelay: number
  showWordCount: boolean
  showLineNumbers: boolean
  darkMode: boolean
  fullscreenMode: boolean
  
  // NEW: Narrative Intelligence editor features
  showAIIndicators?: boolean       // Whether to show indicators for AI-generated content
  autoAcceptAI?: boolean          // Whether to automatically accept AI suggestions
  aiEditingMode?: 'collaborative' | 'assistive' | 'manual'  // How AI integrates with editing
}

// Complete enhanced state interface that includes all narrative intelligence capabilities
// This represents the full evolution of your application's state management
export interface StoryState {
  // === EXISTING CORE STATE (maintained exactly as before) ===
  // Your users' existing workflows continue working without any changes
  currentProject: StoryProject | null
  projects: StoryProject[]
  nodes: StoryNode[]
  currentNodeId: string | null
  selectedNodeIds: string[]
  isEditing: boolean
  editorSettings: EditorSettings
  sidebarCollapsed: boolean
  activeView: "editor" | "flow" | "outline"
  
  // History system for undo/redo functionality (existing)
  history: {
    past: StoryNode[][]
    present: StoryNode[]
    future: StoryNode[][]
  }

  // === EXISTING API STATE (for branch generation and analytics) ===
  // These handle your current AI features like branch generation
  isGeneratingBranches: boolean
  isRegeneratingBranches: boolean
  isAnalyzingStory: boolean
  isCheckingHealth: boolean
  branchGenerationError: string | null
  analysisError: string | null
  connectionError: string | null
  branchOptions: BranchOption[]
  lastBranchGenerationTime: number | null
  serviceHealth: {
    system: boolean
    branches: boolean
    analytics: boolean
    lastChecked: Date | null
  }
  lastAnalysis: any | null
  quickInsights: any | null

  // === ENHANCED STORY STRUCTURE STATE ===
  // These manage the understanding of story connections and narrative flow
  storyStructure: StoryStructure | null     // Complete analysis of how scenes connect
  currentBranchId: string | null            // Which narrative path the user is currently viewing
  isAnalyzingStructure: boolean             // Whether we're currently analyzing story structure
  structureAnalysisError: string | null     // Any errors from structure analysis

  // === NEW: NARRATIVE INTELLIGENCE STATE ===
  // This is where the magic happens - AI that understands story flow and dependencies
  generatedStories: Record<string, GeneratedStory>  // Complete stories for each narrative branch
  isGeneratingNarrative: boolean                    // Whether AI is currently writing story content
  narrativeGenerationQueue: string[]               // Queue of scenes waiting for AI generation
  lastNarrativeUpdate: Date | null                  // When the narrative was last updated
  narrativeInsights: string[]                       // AI insights about story structure and flow
  autoGenerationEnabled: boolean                    // Global toggle for automatic content generation
  narrativeProcessingStatus: {                      // Detailed status of AI processing
    currentlyProcessing: string[]                   // Which scenes are being processed
    queuedForProcessing: string[]                   // Which scenes are waiting
    lastProcessedScene: string | null               // Last scene that was processed
    processingErrors: Record<string, string>        // Any errors during processing
  }

  // === ALL EXISTING ACTIONS (enhanced internally but same interface) ===
  // Your existing code continues to work exactly as before
  createProject: (title: string, description?: string) => string
  updateProject: (id: string, updates: Partial<StoryProject>) => void
  deleteProject: (id: string) => void
  setCurrentProject: (id: string | null) => void
  
  // Node management actions (enhanced with narrative intelligence)
  addNode: (title: string, position?: { x: number; y: number }) => string
  updateNodeContent: (id: string, content: string) => void
  updateNodeTitle: (id: string, title: string) => void
  updateNodeStatus: (id: string, status: StoryNode["status"]) => void
  updateNodePosition: (id: string, position: { x: number; y: number }) => void
  updateNodeNotes: (id: string, notes: string) => void
  addNodeTag: (id: string, tag: string) => void
  removeNodeTag: (id: string, tag: string) => void
  
  // ENHANCED: Connection management with automatic narrative intelligence
  // These now trigger AI story generation when connections change
  connectNodes: (fromId: string, toId: string) => Promise<void>
  disconnectNodes: (fromId: string, toId: string) => Promise<void>
  deleteNode: (id: string) => Promise<void>
  duplicateNode: (id: string) => string

  // Navigation and selection (existing functionality)
  setCurrentNode: (id: string | null) => void
  selectNode: (id: string, multiSelect?: boolean) => void
  clearSelection: () => void
  selectAll: () => void

  // Editor management (existing functionality)
  setIsEditing: (editing: boolean) => void
  updateEditorSettings: (settings: Partial<EditorSettings>) => void
  toggleSidebar: () => void
  setActiveView: (view: "editor" | "flow" | "outline") => void

  // History management (existing functionality)
  undo: () => void
  redo: () => void
  canUndo: () => boolean
  canRedo: () => boolean
  saveToHistory: () => void

  // Bulk operations (existing functionality)
  deleteSelectedNodes: () => void
  updateSelectedNodesStatus: (status: StoryNode["status"]) => void
  moveSelectedNodes: (deltaX: number, deltaY: number) => void

  // Import/Export (enhanced with narrative awareness)
  exportProject: () => string
  importProject: (data: string) => void
  exportNode: (id: string) => string
  importNode: (data: string, position?: { x: number; y: number }) => string

  // Enhanced AI actions (your existing branch generation, now enhanced)
  generateBranches: (nodeId: string, options?: {
    regenerate?: boolean
    genre?: string
    tone?: string
  }) => Promise<void>
  selectBranch: (branch: BranchOption, parentNodeId: string) => void
  clearBranchOptions: () => void
  analyzeStory: () => Promise<any>
  getQuickInsights: () => Promise<any>
  checkServiceHealth: () => Promise<void>
  clearError: (errorType: 'branch' | 'analysis' | 'connection' | 'structure' | 'narrative') => void

  // === NEW: NARRATIVE INTELLIGENCE ACTIONS ===
  // These are completely new capabilities that understand story flow and dependencies
  
  // Core narrative processing functions
  processNarrativeChange: (changes: { fromId: string; toId: string; action: 'added' | 'removed' }[]) => Promise<void>
  toggleAutoGeneration: (enabled: boolean) => void
  regenerateSceneContent: (nodeId: string) => Promise<void>
  regenerateBranchStory: (branchId: string) => Promise<void>
  
  // Story and context access functions
  getGeneratedStory: (branchId: string) => GeneratedStory | null
  getNarrativeContext: (nodeId: string) => NarrativeContext | null
  exportGeneratedStory: (branchId: string, format: 'txt' | 'html' | 'markdown') => string
  getAllGeneratedStories: () => GeneratedStory[]
  
  // Advanced narrative analysis functions
  analyzeNarrativeDependencies: (nodeId: string) => string[]
  validateStoryCoherence: () => Promise<{ issues: string[], suggestions: string[] }>
  optimizeStoryStructure: () => Promise<{ recommendations: string[] }>

  // === ENHANCED EXISTING ACTIONS ===
  // Enhanced story structure analysis (your existing analyzeStoryStructure, now much more powerful)
  analyzeStoryStructure: () => void
  setCurrentBranch: (branchId: string) => void
  exportByBranch: (branchId?: string) => string
  exportAllBranches: () => Record<string, string>
  getBranchContainingNode: (nodeId: string) => StoryBranch | null
  getStoryStructure: () => StoryStructure | null

  // Enhanced getters that now include narrative intelligence data
  getCurrentNode: () => StoryNode | null
  getNodeById: (id: string) => StoryNode | null
  getConnectedNodes: (id: string) => StoryNode[]
  getSelectedNodes: () => StoryNode[]
  getProjectStats: () => {
    // Existing stats
    totalNodes: number
    writtenNodes: number
    draftNodes: number
    suggestionNodes: number
    totalWords: number
    totalCharacters: number
    // Enhanced stats with narrative intelligence
    branchCount: number
    currentBranchWordCount: number
    mainBranchWordCount: number
    isLinearStory: boolean
    orphanedNodesCount: number
    aiGeneratedNodes: number
    completedStories: number
    averageStoryLength: number
    narrativeCoherenceScore: number
  }
  searchNodes: (query: string) => StoryNode[]
  getNodesByTag: (tag: string) => StoryNode[]
  getNodesByStatus: (status: StoryNode["status"]) => StoryNode[]
  extractCharacterNames: () => string[]
}

// Helper functions that support the store operations
// These are the same as your existing implementation, with some enhancements

const defaultEditorSettings: EditorSettings = {
  fontSize: 16,
  fontFamily: "serif",
  lineHeight: 1.6,
  autoSave: true,
  autoSaveDelay: 1000,
  showWordCount: true,
  showLineNumbers: false,
  darkMode: false,
  fullscreenMode: false,
  // NEW: Narrative intelligence editor settings
  showAIIndicators: true,
  autoAcceptAI: false,
  aiEditingMode: 'collaborative'
}

// Enhanced word count calculation that handles HTML content and provides accurate counts
const calculateWordCount = (content: string): number => {
  if (!content || content.trim() === '') return 0
  // Remove HTML tags and clean the text for accurate word counting
  const text = content.replace(/<[^>]*>/g, '').trim()
  if (!text) return 0
  return text.split(/\s+/).filter((word) => word.length > 0).length
}

// Enhanced node creation that includes narrative intelligence metadata
const createNewNode = (title: string, position: { x: number; y: number }): StoryNode => {
  const now = new Date()
  return {
    id: uuidv4(),
    title: title || `Scene ${Math.floor(Math.random() * 1000)}`,
    content: "",
    position,
    connections: [],
    status: "draft",
    createdAt: now,
    updatedAt: now,
    wordCount: 0,
    characterCount: 0,
    tags: [],
    notes: "",
    // NEW: Narrative intelligence metadata
    isAutoGenerated: false,
    generationContext: undefined,
    lastRegeneratedAt: undefined,
    narrativeDependencies: []
  }
}

// Enhanced project creation with narrative intelligence settings
const createNewProject = (title: string, description = ""): StoryProject => {
  const now = new Date()
  return {
    id: uuidv4(),
    title: title || "Untitled Project",
    description,
    createdAt: now,
    updatedAt: now,
    genre: "",
    targetWordCount: undefined,
    // NEW: Narrative intelligence settings with sensible defaults
    autoGenerateContent: true,      // Enable AI generation by default for new projects
    aiWritingStyle: 'adaptive',     // AI adapts to the existing writing style
    narrativeComplexity: 'moderate', // Moderate complexity for most users
    branchIsolation: true,          // Keep story branches separate by default
    contextDepth: 10                // Include up to 10 previous scenes in context
  }
}

// Main Store Creation - The heart of your application's intelligence
// This combines all your existing functionality with sophisticated narrative understanding
export const useStore = create<StoryState>()(
  subscribeWithSelector(
    immer((set, get) => ({
      // === INITIALIZE ALL STATE ===
      // Start with your existing state structure exactly as it was
      currentProject: null,
      projects: [],
      nodes: [],
      currentNodeId: null,
      selectedNodeIds: [],
      isEditing: false,
      editorSettings: defaultEditorSettings,
      sidebarCollapsed: false,
      activeView: "editor",
      history: {
        past: [],
        present: [],
        future: [],
      },

      // Initialize existing API state (your current branch generation, etc.)
      isGeneratingBranches: false,
      isRegeneratingBranches: false,
      isAnalyzingStory: false,
      isCheckingHealth: false,
      branchGenerationError: null,
      analysisError: null,
      connectionError: null,
      branchOptions: [],
      lastBranchGenerationTime: null,
      serviceHealth: {
        system: false,
        branches: false,
        analytics: false,
        lastChecked: null,
      },
      lastAnalysis: null,
      quickInsights: null,

      // Initialize enhanced story structure state
      storyStructure: null,
      currentBranchId: null,
      isAnalyzingStructure: false,
      structureAnalysisError: null,

      // NEW: Initialize narrative intelligence state
      // This is where the AI storytelling capabilities live
      generatedStories: {},
      isGeneratingNarrative: false,
      narrativeGenerationQueue: [],
      lastNarrativeUpdate: null,
      narrativeInsights: [],
      autoGenerationEnabled: true,  // Enable by default for new users
      narrativeProcessingStatus: {
        currentlyProcessing: [],
        queuedForProcessing: [],
        lastProcessedScene: null,
        processingErrors: {}
      },

      // === PROJECT MANAGEMENT (enhanced with narrative intelligence) ===
      
      /**
       * Create a new project with narrative intelligence capabilities enabled
       * This sets up the foundation for AI-powered story generation
       */
      createProject: (title: string, description = "") => {
        console.log('🎯 Creating project with narrative intelligence:', title)
        
        const project = createNewProject(title, description)
        
        set((state) => {
          state.projects.push(project)
          state.currentProject = project
          
          // Reset narrative intelligence state for the new project
          // This ensures each project starts with a clean narrative context
          state.generatedStories = {}
          state.narrativeInsights = []
          state.lastNarrativeUpdate = null
          state.narrativeProcessingStatus = {
            currentlyProcessing: [],
            queuedForProcessing: [],
            lastProcessedScene: null,
            processingErrors: {}
          }
        })
        
        return project.id
      },

      /**
       * Update project settings, including narrative intelligence preferences
       * This allows users to customize how AI generates content for their specific project
       */
      updateProject: (id: string, updates: Partial<StoryProject>) => {
        set((state) => {
          const project = state.projects.find((p) => p.id === id)
          if (project) {
            Object.assign(project, updates, { updatedAt: new Date() })
            if (state.currentProject?.id === id) {
              state.currentProject = project
            }
            
            // If auto-generation settings changed, update the global flag
            if ('autoGenerateContent' in updates) {
              state.autoGenerationEnabled = updates.autoGenerateContent ?? state.autoGenerationEnabled
            }
          }
        })
      },

      deleteProject: (id: string) => {
        set((state) => {
          state.projects = state.projects.filter((p) => p.id !== id)
          if (state.currentProject?.id === id) {
            state.currentProject = null
            state.nodes = []
            state.currentNodeId = null
            state.selectedNodeIds = []
            // Clear all narrative intelligence data when deleting a project
            state.storyStructure = null
            state.currentBranchId = null
            state.generatedStories = {}
            state.narrativeInsights = []
            state.narrativeProcessingStatus = {
              currentlyProcessing: [],
              queuedForProcessing: [],
              lastProcessedScene: null,
              processingErrors: {}
            }
          }
        })
      },

      setCurrentProject: (id: string | null) => {
        set((state) => {
          const project = id ? state.projects.find((p) => p.id === id) : null
          state.currentProject = project || null
          // Reset narrative state when switching projects to avoid cross-contamination
          state.storyStructure = null
          state.currentBranchId = null
          state.generatedStories = {}
          state.narrativeInsights = []
        })
      },

      // === ENHANCED NODE MANAGEMENT ===
      // These functions now include narrative intelligence processing
      
      /**
       * Add a new node to the story
       * This maintains your existing functionality while preparing for narrative intelligence
       */
      addNode: (title: string, position = { x: 0, y: 0 }) => {
        console.log('📝 Adding node with narrative intelligence support:', title)
        
        // Ensure we have a current project (same as your existing logic)
        if (!get().currentProject) {
          console.warn('No current project, creating default project')
          get().createProject('My Story')
        }

        const node = createNewNode(title, position)
        
        set((state) => {
          // Save current state to history before making changes (existing functionality)
          if (state.nodes.length > 0) {
            state.history.past.push([...state.nodes])
            if (state.history.past.length > 50) {
              state.history.past.shift()
            }
            state.history.future = []
          }
          
          state.nodes.push(node)
        })
        
        // Note: We don't trigger narrative generation here because isolated nodes
        // don't have narrative context yet. Generation happens when connections are made.
        
        return node.id
      },

      /**
       * Update node content with narrative intelligence awareness
       * This tracks when users manually edit content vs AI-generated content
       */
      updateNodeContent: (id: string, content: string) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node) {
            node.content = content
            node.wordCount = calculateWordCount(content)
            node.characterCount = content.length
            node.updatedAt = new Date()
            
            // Update status based on content presence (existing logic)
            if (content.trim() && node.status === "draft") {
              node.status = "written"
            }
            
            // NEW: Clear auto-generation flags when user manually edits content
            // This ensures we respect user intent when they override AI content
            if (node.isAutoGenerated) {
              node.isAutoGenerated = false
              node.generationContext = undefined
              console.log('🎨 User edited AI-generated content, marking as manually authored')
            }
          }
        })
        
        // NEW: If this node has connections and auto-generation is enabled,
        // we might want to update dependent scenes, but we'll be conservative
        // and only do this if the user explicitly requests it
      },

      // Standard node update functions (same as your existing implementation)
      updateNodeTitle: (id: string, title: string) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node) {
            node.title = title || 'Untitled Scene'
            node.updatedAt = new Date()
          }
        })
      },

      updateNodeStatus: (id: string, status: StoryNode["status"]) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node) {
            node.status = status
            node.updatedAt = new Date()
          }
        })
      },

      updateNodePosition: (id: string, position: { x: number; y: number }) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node) {
            node.position = position
            node.updatedAt = new Date()
          }
        })
      },

      updateNodeNotes: (id: string, notes: string) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node) {
            node.notes = notes
            node.updatedAt = new Date()
          }
        })
      },

      addNodeTag: (id: string, tag: string) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node && !node.tags.includes(tag)) {
            node.tags.push(tag)
            node.updatedAt = new Date()
          }
        })
      },

      removeNodeTag: (id: string, tag: string) => {
        set((state) => {
          const node = state.nodes.find((n) => n.id === id)
          if (node) {
            node.tags = node.tags.filter((t) => t !== tag)
            node.updatedAt = new Date()
          }
        })
      },

      // === ENHANCED CONNECTION MANAGEMENT ===
      // This is where the narrative intelligence magic really happens
      
      /**
       * Connect two nodes and trigger narrative intelligence processing
       * This is the core integration point where AI story generation activates
       */
      connectNodes: async (fromId: string, toId: string) => {
        console.log('🔗 Connecting nodes with narrative intelligence:', fromId, 'to', toId)
        
        // Step 1: Update the connection in state (exactly as your existing implementation)
        set((state) => {
          // Save to history before making connection changes
          state.history.past.push([...state.nodes])
          if (state.history.past.length > 50) {
            state.history.past.shift()
          }
          state.history.future = []

          const fromNode = state.nodes.find((n) => n.id === fromId)
          if (fromNode && !fromNode.connections.includes(toId)) {
            fromNode.connections.push(toId)
            fromNode.updatedAt = new Date()
            
            // NEW: Update narrative dependencies for the target node
            const toNode = state.nodes.find((n) => n.id === toId)
            if (toNode) {
              if (!toNode.narrativeDependencies) {
                toNode.narrativeDependencies = []
              }
              if (!toNode.narrativeDependencies.includes(fromId)) {
                toNode.narrativeDependencies.push(fromId)
              }
            }
          }
        })
        
        // Step 2: Check if narrative intelligence should process this change
        const { autoGenerationEnabled, currentProject } = get()
        if (!autoGenerationEnabled || !currentProject?.autoGenerateContent) {
          console.log('⏸️ Auto-generation disabled, connection made but no AI processing')
          // Still analyze structure for visualization, just don't generate content
          get().analyzeStoryStructure()
          return
        }
        
        console.log('🧠 Triggering narrative intelligence processing for new connection')
        
        // Step 3: Process the narrative change using our AI engine
        try {
          await get().processNarrativeChange([{ fromId, toId, action: 'added' }])
        } catch (error) {
          console.error('❌ Narrative processing failed during connection:', error)
          // Connection was still made successfully, just the AI processing failed
          // This ensures your basic functionality always works even if AI fails
        }
      },

      /**
       * Disconnect two nodes and update narrative intelligence accordingly
       * This handles the complex case of removing narrative dependencies
       */
      disconnectNodes: async (fromId: string, toId: string) => {
        console.log('🔗💥 Disconnecting nodes with narrative intelligence:', fromId, 'from', toId)
        
        // Step 1: Update the connection in state (same as existing implementation)
        set((state) => {
          state.history.past.push([...state.nodes])
          if (state.history.past.length > 50) {
            state.history.past.shift()
          }
          state.history.future = []

          const fromNode = state.nodes.find((n) => n.id === fromId)
          if (fromNode) {
            fromNode.connections = fromNode.connections.filter((id) => id !== toId)
            fromNode.updatedAt = new Date()
            
            // NEW: Update narrative dependencies for the target node
            const toNode = state.nodes.find((n) => n.id === toId)
            if (toNode && toNode.narrativeDependencies) {
              toNode.narrativeDependencies = toNode.narrativeDependencies.filter(dep => dep !== fromId)
            }
          }
        })
        
        // Step 2: Process narrative changes if auto-generation is enabled
        const { autoGenerationEnabled } = get()
        if (autoGenerationEnabled) {
          console.log('🧠 Processing narrative changes for disconnection')
          try {
            await get().processNarrativeChange([{ fromId, toId, action: 'removed' }])
          } catch (error) {
            console.error('❌ Narrative processing failed during disconnection:', error)
          }
        } else {
          // Still update structure analysis even without narrative generation
          get().analyzeStoryStructure()
        }
      },

      /**
       * Delete a node and handle all narrative dependencies
       * This is complex because we need to update all affected story branches
       */
      deleteNode: async (id: string) => {
        console.log('🗑️ Deleting node with narrative intelligence:', id)
        
        // Step 1: Identify all connections that will be affected by this deletion
        const { nodes } = get()
        const nodeToDelete = nodes.find(n => n.id === id)
        const affectedConnections: { fromId: string; toId: string; action: 'removed' }[] = []
        
        if (nodeToDelete) {
          // Collect all outgoing connections (this node to others)
          nodeToDelete.connections.forEach(targetId => {
            affectedConnections.push({ fromId: id, toId: targetId, action: 'removed' })
          })
          
          // Collect all incoming connections (others to this node)
          nodes.forEach(node => {
            if (node.connections.includes(id)) {
              affectedConnections.push({ fromId: node.id, toId: id, action: 'removed' })
            }
          })
          
          console.log(`📊 Node deletion will affect ${affectedConnections.length} connections`)
        }
        
        // Step 2: Delete the node from state (same as existing implementation)
        set((state) => {
          state.history.past.push([...state.nodes])
          if (state.history.past.length > 50) {
            state.history.past.shift()
          }
          state.history.future = []

          // Remove the node
          state.nodes = state.nodes.filter((n) => n.id !== id)

          // Remove connections to this node from all other nodes
          state.nodes.forEach((node) => {
            node.connections = node.connections.filter((connId) => connId !== id)
            // NEW: Also update narrative dependencies
            if (node.narrativeDependencies) {
              node.narrativeDependencies = node.narrativeDependencies.filter(dep => dep !== id)
            }
          })

          // Clear current node if it was deleted
          if (state.currentNodeId === id) {
            state.currentNodeId = null
          }

          // Remove from selection
          state.selectedNodeIds = state.selectedNodeIds.filter((nodeId) => nodeId !== id)
          
          // NEW: Remove from any narrative processing queues
          state.narrativeGenerationQueue = state.narrativeGenerationQueue.filter(nodeId => nodeId !== id)
          state.narrativeProcessingStatus.currentlyProcessing = 
            state.narrativeProcessingStatus.currentlyProcessing.filter(nodeId => nodeId !== id)
          state.narrativeProcessingStatus.queuedForProcessing = 
            state.narrativeProcessingStatus.queuedForProcessing.filter(nodeId => nodeId !== id)
        })
        
        // Step 3: Process narrative changes for all affected connections
        const { autoGenerationEnabled } = get()
        if (autoGenerationEnabled && affectedConnections.length > 0) {
          console.log('🧠 Processing narrative changes for node deletion')
          try {
            await get().processNarrativeChange(affectedConnections)
          } catch (error) {
            console.error('❌ Narrative processing failed during node deletion:', error)
          }
        } else {
          // Always update structure analysis, even without narrative generation
          get().analyzeStoryStructure()
        }
      },

      /**
       * Duplicate a node with narrative intelligence considerations
       * The duplicated node starts without connections to avoid narrative confusion
       */
      duplicateNode: (id: string) => {
        const originalNode = get().getNodeById(id)
        if (!originalNode) return ""

        console.log('📋 Duplicating node with narrative intelligence considerations:', originalNode.title)

        const duplicatedNode = createNewNode(`${originalNode.title} (Copy)`, {
          x: originalNode.position.x + 50,
          y: originalNode.position.y + 50,
        })
        
        // Copy content and metadata, but not AI generation flags
        // This ensures the user can edit the duplicate without AI interference
        duplicatedNode.content = originalNode.content
        duplicatedNode.status = originalNode.status === 'ai-generated' ? 'draft' : originalNode.status
        duplicatedNode.tags = [...originalNode.tags]
        duplicatedNode.notes = originalNode.notes
        duplicatedNode.wordCount = originalNode.wordCount
        duplicatedNode.characterCount = originalNode.characterCount
        
        // Explicitly clear AI generation metadata for the duplicate
        duplicatedNode.isAutoGenerated = false
        duplicatedNode.generationContext = undefined
        duplicatedNode.lastRegeneratedAt = undefined
        duplicatedNode.narrativeDependencies = []

        set((state) => {
          state.history.past.push([...state.nodes])
          if (state.history.past.length > 50) {
            state.history.past.shift()
          }
          state.history.future = []

          state.nodes.push(duplicatedNode)
        })

        // Note: We don't automatically trigger structure analysis for duplication
        // since the duplicate has no connections yet

        return duplicatedNode.id
      },

      // === NARRATIVE INTELLIGENCE CORE FUNCTIONS ===
      // These are the new capabilities that make your app truly intelligent
      
      /**
       * Process narrative changes using the narrative intelligence engine
       * This is the main orchestrator that handles automatic story generation
       */
      processNarrativeChange: async (
        changes: { fromId: string; toId: string; action: 'added' | 'removed' }[]
      ) => {
        console.log('🧠 Processing narrative changes:', changes.length, 'connections affected')
        
        const { nodes, currentProject } = get()
        
        // Safety check: don't process if we don't have enough context
        if (nodes.length === 0 || !currentProject) {
          console.log('⏸️ Insufficient context for narrative processing, skipping')
          return
        }
        
        // Update processing status to show users what's happening
        set((state) => {
          state.isGeneratingNarrative = true
          state.narrativeInsights = []
          state.narrativeProcessingStatus.currentlyProcessing = changes.map(c => c.toId)
        })
        
        try {
          console.log('🔄 Invoking narrative intelligence engine...')
          
          // Use the narrative intelligence engine to process the changes
          // This is where the magic happens - AI reads the story context and generates appropriate content
          const result = await narrativeEngine.processStoryStructureChange(nodes, changes)
          
          console.log('✅ Narrative processing complete:', {
            updatedNodes: result.updatedNodes.length,
            generatedStories: result.generatedStories.length,
            insights: result.analysisInsights.length
          })
          
          // Update state with all the AI-generated results
          set((state) => {
            // Update nodes with generated content
            result.updatedNodes.forEach(updatedNode => {
              const index = state.nodes.findIndex(n => n.id === updatedNode.id)
              if (index !== -1) {
                state.nodes[index] = {
                  ...updatedNode,
                  isAutoGenerated: true,
                  lastRegeneratedAt: new Date(),
                  status: updatedNode.content.trim() ? 'ai-generated' : 'draft'
                }
                console.log(`📝 Updated content for scene: ${updatedNode.title}`)
              }
            })
            
            // Store complete generated stories for each branch
            result.generatedStories.forEach(story => {
              state.generatedStories[story.branchId] = story
              console.log(`📖 Generated complete story for branch: ${story.title} (${story.wordCount} words)`)
            })
            
            // Update insights and metadata
            state.narrativeInsights = result.analysisInsights
            state.lastNarrativeUpdate = new Date()
            state.isGeneratingNarrative = false
            state.narrativeProcessingStatus = {
              currentlyProcessing: [],
              queuedForProcessing: [],
              lastProcessedScene: result.updatedNodes[result.updatedNodes.length - 1]?.id || null,
              processingErrors: {}
            }
          })
          
          // Also trigger structure analysis to update branch visualization
          get().analyzeStoryStructure()
          
          console.log('🎉 Narrative intelligence processing completed successfully')
          
        } catch (error) {
          console.error('❌ Narrative processing failed:', error)
          
          set((state) => {
            state.isGeneratingNarrative = false
            state.structureAnalysisError = getErrorMessage(error)
            state.narrativeProcessingStatus = {
              currentlyProcessing: [],
              queuedForProcessing: [],
              lastProcessedScene: null,
              processingErrors: {
                [new Date().toISOString()]: getErrorMessage(error)
              }
            }
          })
        }
      },

      /**
       * Toggle automatic content generation on/off
       * This gives users full control over when AI intervenes in their writing
       */
      toggleAutoGeneration: (enabled: boolean) => {
        console.log('🔄 Toggling auto-generation:', enabled ? 'ON' : 'OFF')
        
        set((state) => {
          state.autoGenerationEnabled = enabled
          
          // Also update current project settings to persist this preference
          if (state.currentProject) {
            state.currentProject.autoGenerateContent = enabled
          }
        })
        
        // If turning off, clear any pending generation work
        if (!enabled) {
          set((state) => {
            state.narrativeGenerationQueue = []
            state.narrativeProcessingStatus.queuedForProcessing = []
          })
        }
      },

      /**
       * Manually regenerate content for a specific scene
       * This allows users to get fresh AI content for any scene they choose
       */
      regenerateSceneContent: async (nodeId: string) => {
        console.log('✍️ Manually regenerating content for scene:', nodeId)
        
        const { nodes } = get()
        const targetNode = nodes.find(n => n.id === nodeId)
        
        if (!targetNode) {
          throw new Error('Scene not found for regeneration')
        }
        
        // Find all incoming connections to this node to establish context
        const incomingConnections = nodes
          .filter(n => n.connections.includes(nodeId))
          .map(n => ({ fromId: n.id, toId: nodeId, action: 'added' as const }))
        
        if (incomingConnections.length > 0) {
          // Process as if these connections were just made, forcing regeneration
          await get().processNarrativeChange(incomingConnections)
        } else {
          // For isolated nodes, still try to generate opening content
          console.log('🌱 Generating opening content for isolated scene')
          await get().processNarrativeChange([])
        }
      },

      /**
       * Regenerate the complete story for a specific branch
       * This rebuilds the entire narrative for a story path from scratch
       */
      regenerateBranchStory: async (branchId: string) => {
        console.log('📖 Regenerating complete story for branch:', branchId)
        
        const { storyStructure } = get()
        if (!storyStructure) {
          throw new Error('No story structure available for branch regeneration')
        }
        
        // Find the target branch in our story structure
        const allBranches = [storyStructure.mainBranch, ...storyStructure.alternateBranches]
        const targetBranch = allBranches.find(b => b.id === branchId)
        
        if (!targetBranch) {
          throw new Error(`Branch not found: ${branchId}`)
        }
        
        console.log(`🔄 Regenerating ${targetBranch.nodes.length} scenes in branch: ${targetBranch.title}`)
        
        // Create connection changes for all sequential scenes in the branch
        // This forces regeneration of the entire narrative flow
        const branchConnections = targetBranch.nodes.slice(1).map((node, index) => ({
          fromId: targetBranch.nodes[index].id,
          toId: node.id,
          action: 'added' as const
        }))
        
        await get().processNarrativeChange(branchConnections)
      },

      /**
       * Get the generated complete story for a specific branch
       * This provides access to the AI-assembled narrative for any story path
       */
      getGeneratedStory: (branchId: string) => {
        const { generatedStories } = get()
        return generatedStories[branchId] || null
      },

      /**
       * Get all generated stories across all branches
       * This gives users access to all the complete narratives their structure has produced
       */
      getAllGeneratedStories: () => {
        const { generatedStories } = get()
        return Object.values(generatedStories)
      },

      /**
       * Get narrative context for a specific scene
       * This shows users exactly what context the AI has when writing any scene
       */
      getNarrativeContext: (nodeId: string) => {
        const { nodes, storyStructure } = get()
        
        if (!storyStructure) return null
        
        // Find which branch this node belongs to
        const allBranches = [storyStructure.mainBranch, ...storyStructure.alternateBranches]
        
        for (const branch of allBranches) {
          const nodeIndex = branch.nodes.findIndex(n => n.id === nodeId)
          if (nodeIndex !== -1) {
            // Build comprehensive context information
            const predecessorNodes = branch.nodes.slice(0, nodeIndex)
            const contextText = predecessorNodes.map(n => n.content).filter(c => c.trim()).join('\n\n---\n\n')
            
            return {
              currentNodeId: nodeId,
              predecessorNodes,
              branchId: branch.id,
              positionInBranch: nodeIndex + 1,
              totalScenesInBranch: branch.nodes.length,
              contextText,
              characterNames: get().extractCharacterNames(),
              establishedElements: {
                settings: [],
                plotPoints: [],
                relationships: [],
                conflicts: []
              }
            }
          }
        }
        
        return null
      },

      /**
       * Export a generated story in various formats
       * This allows users to get their AI-generated stories in publishable formats
       */
      exportGeneratedStory: (branchId: string, format: 'txt' | 'html' | 'markdown') => {
        const story = get().getGeneratedStory(branchId)
        
        if (!story) {
          throw new Error(`No generated story found for branch: ${branchId}`)
        }
        
        console.log(`📤 Exporting generated story "${story.title}" as ${format.toUpperCase()}`)
        
        switch (format) {
          case 'txt':
            return story.fullText
            
          case 'markdown':
            return `# ${story.title}\n\n` +
                   `*Generated on ${new Date().toLocaleDateString()}*\n` +
                   `*${story.wordCount} words, ${story.estimatedReadingTime} minute read*\n\n` +
                   `---\n\n` +
                   story.scenes.map(scene => 
                     `## ${scene.title}\n\n${scene.content}`
                   ).join('\n\n---\n\n')
            
          case 'html':
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${story.title}</title>
    <style>
        body { font-family: serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.6; }
        h1 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
        h2 { color: #555; margin-top: 2rem; }
        .metadata { color: #666; font-style: italic; margin-bottom: 2rem; }
        .scene-break { text-align: center; margin: 2rem 0; color: #999; }
    </style>
</head>
<body>
    <h1>${story.title}</h1>
    <div class="metadata">
        Generated on ${new Date().toLocaleDateString()} • 
        ${story.wordCount} words • 
        ${story.estimatedReadingTime} minute read
    </div>
    ${story.scenes.map(scene => 
        `<h2>${scene.title}</h2><div>${scene.content.replace(/\n/g, '</p><p>')}</div>`
    ).join('<div class="scene-break">* * *</div>')}
</body>
</html>`
            
          default:
            return story.fullText
        }
      },

      /**
       * Analyze narrative dependencies for a specific scene
       * This helps users understand how scenes influence each other
       */
      analyzeNarrativeDependencies: (nodeId: string) => {
        const { nodes } = get()
        const targetNode = nodes.find(n => n.id === nodeId)
        
        if (!targetNode) return []
        
        // Return the list of scenes this node depends on for narrative context
        return targetNode.narrativeDependencies || []
      },

      /**
       * Validate story coherence across all branches
       * This provides advanced analysis of narrative consistency
       */
      validateStoryCoherence: async () => {
        console.log('🔍 Validating story coherence across all branches')
        
        const { storyStructure, generatedStories } = get()
        const issues: string[] = []
        const suggestions: string[] = []
        
        if (!storyStructure) {
          issues.push('Story structure not analyzed - connect scenes to enable coherence validation')
          return { issues, suggestions }
        }
        
        // Check for orphaned nodes
        if (storyStructure.orphanedNodes.length > 0) {
          issues.push(`${storyStructure.orphanedNodes.length} scenes are not connected to any story flow`)
          suggestions.push('Consider connecting isolated scenes to your main narrative or alternate branches')
        }
        
        // Check for incomplete branches
        const incompleteBranches = [storyStructure.mainBranch, ...storyStructure.alternateBranches]
          .filter(branch => branch.nodes.some(node => !node.content.trim()))
        
        if (incompleteBranches.length > 0) {
          issues.push(`${incompleteBranches.length} story branches have scenes without content`)
          suggestions.push('Enable auto-generation or manually write content for empty scenes')
        }
        
        // Check for very short branches
        const shortBranches = [storyStructure.mainBranch, ...storyStructure.alternateBranches]
          .filter(branch => branch.nodes.length < 3)
        
        if (shortBranches.length > 0) {
          suggestions.push('Consider expanding short story branches with additional scenes for fuller narratives')
        }
        
        return { issues, suggestions }
      },

      /**
       * Optimize story structure for better narrative flow
       * This provides AI-powered recommendations for improving story organization
       */
      optimizeStoryStructure: async () => {
        console.log('🎯 Analyzing story structure for optimization opportunities')
        
        const { storyStructure } = get()
        const recommendations: string[] = []
        
        if (!storyStructure) {
          recommendations.push('Connect your scenes to enable structure optimization analysis')
          return { recommendations }
        }
        
        // Analyze branch balance
        if (storyStructure.alternateBranches.length > 0) {
          const mainBranchLength = storyStructure.mainBranch.wordCount
          const averageAlternateLength = storyStructure.alternateBranches.reduce((sum, branch) => 
            sum + branch.wordCount, 0) / storyStructure.alternateBranches.length
          
          if (mainBranchLength < averageAlternateLength * 0.5) {
            recommendations.push('Your main story branch is significantly shorter than your alternate branches')
          }
        }
        
        // Suggest potential connections
        if (storyStructure.orphanedNodes.length > 2) {
          recommendations.push('Consider creating sub-plots by connecting some of your isolated scenes')
        }
        
        // Analyze narrative complexity
        if (storyStructure.totalBranches > 5) {
          recommendations.push('Your story has many branches - consider whether all are necessary for your narrative goals')
        }
        
        return { recommendations }
      },

      // === ALL EXISTING ACTIONS (enhanced but maintaining same interface) ===
      // These maintain your existing functionality while adding narrative intelligence
      
      // Enhanced story structure analysis (your existing function, now much more powerful)
      analyzeStoryStructure: () => {
        console.log('🔍 Analyzing story structure with narrative intelligence')
        
        const { nodes } = get()
        
        set((state) => {
          state.isAnalyzingStructure = true
          state.structureAnalysisError = null
        })
        
        try {
          // Use our enhanced graph analysis to understand story structure
          const structure = analyzeStoryGraph(nodes)
          
          set((state) => {
            state.storyStructure = structure
            state.isAnalyzingStructure = false
            
            // Auto-select the main branch if no branch is currently selected
            if (!state.currentBranchId && structure.mainBranch.nodes.length > 0) {
              state.currentBranchId = structure.mainBranch.id
            }
          })
          
          console.log(`✅ Structure analysis complete: ${structure.totalBranches} branches, ${structure.orphanedNodes.length} orphaned nodes`)
          
        } catch (error) {
          console.error('❌ Story structure analysis failed:', error)
          
          set((state) => {
            state.isAnalyzingStructure = false
            state.structureAnalysisError = getErrorMessage(error)
            state.storyStructure = null
          })
        }
      },

      // Enhanced branch navigation
      setCurrentBranch: (branchId: string) => {
        console.log(`🎯 Switching to branch: ${branchId}`)
        
        set((state) => {
          state.currentBranchId = branchId
        })
        
        // Optionally set the current node to the first node in this branch
        const structure = get().storyStructure
        if (structure) {
          const branch = [structure.mainBranch, ...structure.alternateBranches]
            .find(b => b.id === branchId)
          
          if (branch && branch.nodes.length > 0) {
            get().setCurrentNode(branch.nodes[0].id)
          }
        }
      },

      // Enhanced export that respects narrative structure
      exportByBranch: (branchId?: string) => {
        console.log(`📤 Exporting branch: ${branchId || 'main'}`)
        
        const { storyStructure, currentProject } = get()
        
        if (!storyStructure) {
          console.warn('No story structure available, falling back to chronological export')
          return get().exportProject()
        }
        
        // Find the requested branch
        const targetBranch = branchId 
          ? [storyStructure.mainBranch, ...storyStructure.alternateBranches]
              .find(branch => branch.id === branchId)
          : storyStructure.mainBranch
        
        if (!targetBranch) {
          throw new Error(`Branch not found: ${branchId}`)
        }
        
        // Create export with both scene data and generated story
        const generatedStory = get().getGeneratedStory(targetBranch.id)
        const storyContent = generatedStory ? generatedStory.fullText : getLinearStoryFromBranch(targetBranch)
        
        const exportData = {
          project: currentProject,
          branch: {
            id: targetBranch.id,
            title: targetBranch.title,
            wordCount: targetBranch.wordCount,
            isComplete: targetBranch.isComplete,
            scenes: targetBranch.nodes,
            generatedStory: generatedStory,
            content: storyContent
          },
          exportedAt: new Date(),
          exportType: 'branch-aware',
          version: '2.0'
        }
        
        return JSON.stringify(exportData, null, 2)
      },

      // Enhanced export for all branches
      exportAllBranches: () => {
        console.log('📤 Exporting all story branches with generated content')
        
        const { storyStructure, currentProject, generatedStories } = get()
        
        if (!storyStructure) {
          throw new Error('No story structure available for comprehensive export')
        }
        
        const branchExports = exportAllStoryBranches(storyStructure)
        const enrichedExports: Record<string, any> = {}
        
        // Main branch export with generated story
        const mainGeneratedStory = generatedStories[storyStructure.mainBranch.id]
        enrichedExports['main_story'] = {
          type: 'main_branch',
          title: storyStructure.mainBranch.title,
          wordCount: storyStructure.mainBranch.wordCount,
          scenes: storyStructure.mainBranch.nodes,
          generatedStory: mainGeneratedStory,
          content: mainGeneratedStory ? mainGeneratedStory.fullText : branchExports['main_story'],
          project: currentProject
        }
        
        // Alternate branch exports with generated stories
        storyStructure.alternateBranches.forEach((branch, index) => {
          const key = `alternate_branch_${index + 1}`
          const branchGeneratedStory = generatedStories[branch.id]
          
          enrichedExports[key] = {
            type: 'alternate_branch',
            title: branch.title,
            wordCount: branch.wordCount,
            scenes: branch.nodes,
            generatedStory: branchGeneratedStory,
            content: branchGeneratedStory ? branchGeneratedStory.fullText : branchExports[key],
            project: currentProject
          }
        })
        
        return enrichedExports
      },

      // Find which branch contains a specific node (enhanced with narrative context)
      getBranchContainingNode: (nodeId: string) => {
        const { storyStructure } = get()
        
        if (!storyStructure) {
          return null
        }
        
        const allBranches = [storyStructure.mainBranch, ...storyStructure.alternateBranches]
        
        for (const branch of allBranches) {
          if (branch.nodes.some(node => node.id === nodeId)) {
            return branch
          }
        }
        
        return null
      },

      getStoryStructure: () => {
        return get().storyStructure
      },

      // === EXISTING API ACTIONS (maintained exactly as before) ===
      // Your current branch generation and analytics continue working unchanged
      
      generateBranches: async (nodeId: string, options = {}) => {
        // Your existing implementation remains exactly the same
        const { regenerate = false, genre = '', tone = 'neutral' } = options
        
        console.log(`🤖 ${regenerate ? 'Regenerating' : 'Generating'} branches for node:`, nodeId)

        const node = get().getNodeById(nodeId)
        if (!node) {
          console.error('❌ Node not found:', nodeId)
          set((state) => {
            state.branchGenerationError = 'Scene not found. Please select a valid scene.'
          })
          return
        }

        set((state) => {
          state.branchGenerationError = null
          state.isGeneratingBranches = !regenerate
          state.isRegeneratingBranches = regenerate
          if (regenerate) {
            state.branchOptions = []
          }
        })

        try {
          const characterNames = get().extractCharacterNames()
          const currentProject = get().currentProject
          
          const request = {
            context: node.content || node.title,
            current_node_id: nodeId,
            character_names: characterNames,
            genre: genre || currentProject?.genre || '',
            tone: tone,
          }

          console.log('📤 Sending branch request:', request)

          const response = regenerate 
            ? await branchService.regenerateBranches(request)
            : await branchService.generateBranches(request)

          console.log('✅ Branches generated successfully:', response.options.length, 'options')

          set((state) => {
            state.branchOptions = response.options
            state.lastBranchGenerationTime = response.generation_time
            state.isGeneratingBranches = false
            state.isRegeneratingBranches = false
          })

        } catch (error) {
          console.error('❌ Branch generation failed:', error)
          
          const errorMessage = getErrorMessage(error)
          
          set((state) => {
            state.branchGenerationError = errorMessage
            state.isGeneratingBranches = false
            state.isRegeneratingBranches = false
            state.branchOptions = []
          })
        }
      },

      // Enhanced branch selection that integrates with narrative intelligence
      selectBranch: (branch: BranchOption, parentNodeId: string) => {
        console.log('🎯 Selecting branch with narrative intelligence:', branch.title)

        try {
          const parentNode = get().getNodeById(parentNodeId)
          if (!parentNode) {
            throw new Error('Parent node not found')
          }

          const newPosition = {
            x: parentNode.position.x + 250 + (Math.random() - 0.5) * 100,
            y: parentNode.position.y + (Math.random() - 0.5) * 200,
          }

          const newNodeId = get().addNode(branch.title, newPosition)

          // Set up the new node with AI-generated content and metadata
          get().updateNodeContent(newNodeId, branch.content)
          get().updateNodeStatus(newNodeId, 'ai-generated')  // Mark as AI-generated

          // Add metadata tags for tracking
          branch.characters.forEach(character => {
            get().addNodeTag(newNodeId, `character:${character}`)
          })

          get().addNodeTag(newNodeId, `impact:${branch.impact}`)
          branch.tags.forEach(tag => {
            get().addNodeTag(newNodeId, tag)
          })

          // Create the connection, which will trigger narrative intelligence
          get().connectNodes(parentNodeId, newNodeId)
          get().setCurrentNode(newNodeId)
          get().clearBranchOptions()

          console.log('✅ Branch adopted and integrated with narrative intelligence')

        } catch (error) {
          console.error('❌ Failed to select branch:', error)
          set((state) => {
            state.branchGenerationError = getErrorMessage(error)
          })
        }
      },

      clearBranchOptions: () => {
        set((state) => {
          state.branchOptions = []
          state.branchGenerationError = null
        })
      },

      // Enhanced story analysis that includes narrative intelligence insights
      analyzeStory: async () => {
        console.log('📊 Starting comprehensive story analysis with narrative intelligence')
        
        const { storyStructure, currentProject, generatedStories } = get()
        
        if (!storyStructure) {
          get().analyzeStoryStructure()
          await new Promise(resolve => setTimeout(resolve, 500))
        }
        
        const updatedStructure = get().storyStructure
        if (!updatedStructure) {
          set((state) => {
            state.analysisError = 'Unable to analyze story structure. Please ensure your scenes are connected.'
          })
          return null
        }
        
        set((state) => {
          state.isAnalyzingStory = true
          state.analysisError = null
        })
        
        try {
          // Analyze each branch separately using narrative intelligence
          const branchAnalyses = []
          
          // Analyze main branch
          if (updatedStructure.mainBranch.nodes.length > 0) {
            const mainBranchRequest = {
              nodes: updatedStructure.mainBranch.nodes,
              project_info: currentProject!,
              branch_info: {
                type: 'main',
                title: updatedStructure.mainBranch.title,
                isComplete: updatedStructure.mainBranch.isComplete,
                generatedStory: generatedStories[updatedStructure.mainBranch.id]
              }
            }
            
            const mainAnalysis = await analyticsService.analyzeStory(mainBranchRequest)
            branchAnalyses.push({
              branchType: 'main',
              branchId: updatedStructure.mainBranch.id,
              analysis: mainAnalysis
            })
          }
          
          // Analyze alternate branches (limit to prevent overwhelming)
          const branchesToAnalyze = updatedStructure.alternateBranches.slice(0, 3)
          
          for (const branch of branchesToAnalyze) {
            if (branch.nodes.length > 2) {
              const branchRequest = {
                nodes: branch.nodes,
                project_info: currentProject!,
                branch_info: {
                  type: 'alternate',
                  title: branch.title,
                  isComplete: branch.isComplete,
                  generatedStory: generatedStories[branch.id]
                }
              }
              
              const branchAnalysis = await analyticsService.analyzeStory(branchRequest)
              branchAnalyses.push({
                branchType: 'alternate',
                branchId: branch.id,
                analysis: branchAnalysis
              })
            }
          }
          
          // Create comprehensive analysis that includes narrative intelligence insights
          const comprehensiveAnalysis = {
            storyStructure: updatedStructure,
            branchAnalyses: branchAnalyses,
            generatedStories: Object.values(generatedStories),
            narrativeIntelligence: {
              totalGeneratedWords: Object.values(generatedStories).reduce((sum, story) => sum + story.wordCount, 0),
              averageReadingTime: Object.values(generatedStories).reduce((sum, story) => sum + story.estimatedReadingTime, 0) / Object.values(generatedStories).length || 0,
              genreConsistency: analyzeGenreConsistency(Object.values(generatedStories)),
              characterPresence: analyzeCharacterPresence(Object.values(generatedStories))
            },
            overallInsights: generateComprehensiveInsights(updatedStructure, branchAnalyses, Object.values(generatedStories)),
            analysisTimestamp: new Date()
          }
          
          set((state) => {
            state.isAnalyzingStory = false
            state.lastAnalysis = comprehensiveAnalysis
          })
          
          console.log('✅ Comprehensive story analysis completed successfully')
          return comprehensiveAnalysis
          
        } catch (error) {
          console.error('❌ Story analysis failed:', error)
          
          set((state) => {
            state.analysisError = getErrorMessage(error)
            state.isAnalyzingStory = false
          })
          
          return null
        }
      },

      // All other existing actions remain exactly the same...
      getQuickInsights: async () => {
        // Your existing implementation
        console.log('⚡ Getting quick story insights')

        const { nodes, currentProject } = get()
        
        if (nodes.length === 0) return null

        try {
          const request = {
            nodes: nodes,
            project_info: currentProject!,
          }

          const insights = await analyticsService.getQuickInsights(request)
          
          set((state) => {
            state.quickInsights = insights
          })
          
          console.log('✅ Quick insights generated')
          return insights

        } catch (error) {
          console.error('❌ Quick insights failed:', error)
          return null
        }
      },

      checkServiceHealth: async () => {
        // Your existing implementation
        console.log('🔍 Checking backend service health')

        set((state) => {
          state.isCheckingHealth = true
          state.connectionError = null
        })

        try {
          const health = await healthService.checkAllServices()
          
          set((state) => {
            state.serviceHealth = {
              ...health,
              lastChecked: new Date(),
            }
            state.isCheckingHealth = false
            state.connectionError = null
          })

          console.log('✅ Health check completed:', health)

        } catch (error) {
          console.error('❌ Health check failed:', error)
          
          set((state) => {
            state.connectionError = getErrorMessage(error)
            state.isCheckingHealth = false
            state.serviceHealth = {
              system: false,
              branches: false,
              analytics: false,
              lastChecked: new Date(),
            }
          })
        }
      },

      clearError: (errorType: 'branch' | 'analysis' | 'connection' | 'structure' | 'narrative') => {
        set((state) => {
          switch (errorType) {
            case 'branch':
              state.branchGenerationError = null
              break
            case 'analysis':
              state.analysisError = null
              break
            case 'connection':
              state.connectionError = null
              break
            case 'structure':
              state.structureAnalysisError = null
              break
            case 'narrative':
              state.narrativeProcessingStatus.processingErrors = {}
              break
          }
        })
      },

      // === NAVIGATION AND SELECTION (unchanged) ===
      setCurrentNode: (id: string | null) => {
        console.log('🎯 Setting current node:', id)
        set((state) => {
          state.currentNodeId = id
        })
      },

      selectNode: (id: string, multiSelect = false) => {
        set((state) => {
          if (multiSelect) {
            if (state.selectedNodeIds.includes(id)) {
              state.selectedNodeIds = state.selectedNodeIds.filter((nodeId) => nodeId !== id)
            } else {
              state.selectedNodeIds.push(id)
            }
          } else {
            state.selectedNodeIds = [id]
          }
        })
      },

      clearSelection: () => {
        set((state) => {
          state.selectedNodeIds = []
        })
      },

      selectAll: () => {
        set((state) => {
          state.selectedNodeIds = state.nodes.map((n) => n.id)
        })
      },

      // === EDITOR ACTIONS (unchanged) ===
      setIsEditing: (editing: boolean) => {
        set((state) => {
          state.isEditing = editing
        })
      },

      updateEditorSettings: (settings: Partial<EditorSettings>) => {
        set((state) => {
          Object.assign(state.editorSettings, settings)
        })
      },

      toggleSidebar: () => {
        set((state) => {
          state.sidebarCollapsed = !state.sidebarCollapsed
        })
      },

      setActiveView: (view: "editor" | "flow" | "outline") => {
        set((state) => {
          state.activeView = view
        })
      },

      // === HISTORY ACTIONS (enhanced to work with narrative intelligence) ===
      saveToHistory: () => {
        console.log('💾 History save called - handled inline in operations')
      },

      undo: () => {
        const { history } = get()
        if (history.past.length === 0) return

        set((state) => {
          const previous = state.history.past.pop()!
          state.history.future.unshift([...state.nodes])
          state.nodes = previous
        })
        
        // Re-analyze structure after undo, but don't regenerate content
        setTimeout(() => {
          get().analyzeStoryStructure()
        }, 100)
      },

      redo: () => {
        const { history } = get()
        if (history.future.length === 0) return

        set((state) => {
          const next = state.history.future.shift()!
          state.history.past.push([...state.nodes])
          state.nodes = next
        })
        
        // Re-analyze structure after redo, but don't regenerate content
        setTimeout(() => {
          get().analyzeStoryStructure()
        }, 100)
      },

      canUndo: () => get().history.past.length > 0,
      canRedo: () => get().history.future.length > 0,

      // === BULK OPERATIONS (enhanced with narrative intelligence) ===
      deleteSelectedNodes: () => {
        const { selectedNodeIds } = get()
        if (selectedNodeIds.length === 0) return

        console.log('🗑️ Bulk deleting nodes:', selectedNodeIds.length)

        set((state) => {
          state.history.past.push([...state.nodes])
          if (state.history.past.length > 50) {
            state.history.past.shift()
          }
          state.history.future = []

          selectedNodeIds.forEach((id) => {
            state.nodes = state.nodes.filter((n) => n.id !== id)

            state.nodes.forEach((node) => {
              node.connections = node.connections.filter((connId) => connId !== id)
              if (node.narrativeDependencies) {
                node.narrativeDependencies = node.narrativeDependencies.filter(dep => dep !== id)
              }
            })

            if (state.currentNodeId === id) {
              state.currentNodeId = null
            }
          })

          state.selectedNodeIds = []
          
          // Clear from narrative processing queues
          state.narrativeGenerationQueue = state.narrativeGenerationQueue.filter(id => !selectedNodeIds.includes(id))
        })
        
        // Re-analyze structure after bulk deletion
        get().analyzeStoryStructure()
      },

      updateSelectedNodesStatus: (status: StoryNode["status"]) => {
        const { selectedNodeIds } = get()
        if (selectedNodeIds.length === 0) return

        set((state) => {
          selectedNodeIds.forEach((id) => {
            const node = state.nodes.find((n) => n.id === id)
            if (node) {
              node.status = status
              node.updatedAt = new Date()
              
              // Clear AI generation flags if manually setting status
              if (status !== 'ai-generated') {
                node.isAutoGenerated = false
              }
            }
          })
        })
      },

      moveSelectedNodes: (deltaX: number, deltaY: number) => {
        const { selectedNodeIds } = get()
        if (selectedNodeIds.length === 0) return

        set((state) => {
          selectedNodeIds.forEach((id) => {
            const node = state.nodes.find((n) => n.id === id)
            if (node) {
              node.position.x += deltaX
              node.position.y += deltaY
              node.updatedAt = new Date()
            }
          })
        })
      },

      // === IMPORT/EXPORT (enhanced with narrative intelligence data) ===
      exportProject: () => {
        const { currentProject, nodes, generatedStories, narrativeInsights } = get()
        return JSON.stringify(
          {
            project: currentProject,
            nodes,
            generatedStories,
            narrativeInsights,
            exportedAt: new Date(),
            version: "2.0",
            features: ["narrative-intelligence", "branch-awareness"]
          },
          null,
          2,
        )
      },

      importProject: (data: string) => {
        try {
          const parsed = JSON.parse(data)
          set((state) => {
            if (parsed.project) {
              state.currentProject = parsed.project
              if (!state.projects.find(p => p.id === parsed.project.id)) {
                state.projects.push(parsed.project)
              }
            }
            if (parsed.nodes) {
              state.nodes = parsed.nodes
            }
            
            // Import narrative intelligence data if available
            if (parsed.generatedStories) {
              state.generatedStories = parsed.generatedStories
            }
            if (parsed.narrativeInsights) {
              state.narrativeInsights = parsed.narrativeInsights
            }
            
            state.currentNodeId = null
            state.selectedNodeIds = []
            state.storyStructure = null
            state.currentBranchId = null
          })
          
          // Analyze structure of imported project
          setTimeout(() => {
            get().analyzeStoryStructure()
          }, 500)
          
        } catch (error) {
          console.error("Failed to import project:", error)
        }
      },

      exportNode: (id: string) => {
        const node = get().getNodeById(id)
        if (!node) return ""

        return JSON.stringify(
          {
            node,
            exportedAt: new Date(),
            version: "2.0",
          },
          null,
          2,
        )
      },

      importNode: (data: string, position = { x: 0, y: 0 }) => {
        try {
          const parsed = JSON.parse(data)
          if (!parsed.node) return ""

          const newNode = {
            ...parsed.node,
            id: uuidv4(),
            position,
            connections: [],
            createdAt: new Date(),
            updatedAt: new Date(),
            // Clear AI generation metadata for imported nodes
            isAutoGenerated: false,
            generationContext: undefined,
            lastRegeneratedAt: undefined,
            narrativeDependencies: []
          }

          set((state) => {
            state.nodes.push(newNode)
          })

          return newNode.id
        } catch (error) {
          console.error("Failed to import node:", error)
          return ""
        }
      },

      // === ENHANCED GETTERS (now include narrative intelligence data) ===
      getCurrentNode: () => {
        const { nodes, currentNodeId } = get()
        return currentNodeId ? nodes.find((n) => n.id === currentNodeId) || null : null
      },

      getNodeById: (id: string) => {
        const { nodes } = get()
        return nodes.find((n) => n.id === id) || null
      },

      getConnectedNodes: (id: string) => {
        const { nodes } = get()
        const node = nodes.find((n) => n.id === id)
        if (!node) return []

        return node.connections.map((connId) => nodes.find((n) => n.id === connId)).filter(Boolean) as StoryNode[]
      },

      getSelectedNodes: () => {
        const { nodes, selectedNodeIds } = get()
        return selectedNodeIds.map((id) => nodes.find((n) => n.id === id)).filter(Boolean) as StoryNode[]
      },

      // Enhanced project stats that include narrative intelligence metrics
      getProjectStats: () => {
        const { nodes, storyStructure, generatedStories } = get()
        
        const basicStats = {
          totalNodes: nodes.length,
          writtenNodes: nodes.filter((n) => n.status === "written").length,
          draftNodes: nodes.filter((n) => n.status === "draft").length,
          suggestionNodes: nodes.filter((n) => n.status === "suggestion").length,
          totalWords: nodes.reduce((acc, node) => acc + node.wordCount, 0),
          totalCharacters: nodes.reduce((acc, node) => acc + node.characterCount, 0),
        }
        
        // Enhanced stats with narrative intelligence
        const aiGeneratedNodes = nodes.filter(n => n.isAutoGenerated || n.status === 'ai-generated').length
        const completedStories = Object.keys(generatedStories).length
        const totalGeneratedWords = Object.values(generatedStories).reduce((sum, story) => sum + story.wordCount, 0)
        
        // Calculate narrative coherence score based on connected vs isolated nodes
        const connectedNodes = nodes.filter(n => n.connections.length > 0 || 
          nodes.some(other => other.connections.includes(n.id))).length
        const narrativeCoherenceScore = nodes.length > 0 ? Math.round((connectedNodes / nodes.length) * 100) : 0
        
        if (storyStructure) {
          return {
            ...basicStats,
            branchCount: storyStructure.totalBranches,
            currentBranchWordCount: storyStructure.mainBranch.wordCount,
            mainBranchWordCount: storyStructure.mainBranch.wordCount,
            isLinearStory: storyStructure.isLinear,
            orphanedNodesCount: storyStructure.orphanedNodes.length,
            aiGeneratedNodes,
            completedStories,
            averageStoryLength: completedStories > 0 ? Math.round(totalGeneratedWords / completedStories) : 0,
            narrativeCoherenceScore
          }
        }
        
        return {
          ...basicStats,
          branchCount: 0,
          currentBranchWordCount: 0,
          mainBranchWordCount: 0,
          isLinearStory: nodes.length <= 1,
          orphanedNodesCount: nodes.length,
          aiGeneratedNodes,
          completedStories,
          averageStoryLength: 0,
          narrativeCoherenceScore
        }
      },

      // All other existing getters remain the same
      searchNodes: (query: string) => {
        const { nodes } = get()
        const lowercaseQuery = query.toLowerCase()
        return nodes.filter(
          (node) =>
            node.title.toLowerCase().includes(lowercaseQuery) ||
            node.content.toLowerCase().includes(lowercaseQuery) ||
            node.notes.toLowerCase().includes(lowercaseQuery) ||
            node.tags.some((tag) => tag.toLowerCase().includes(lowercaseQuery)),
        )
      },

      getNodesByTag: (tag: string) => {
        const { nodes } = get()
        return nodes.filter((node) => node.tags.includes(tag))
      },

      getNodesByStatus: (status: StoryNode["status"]) => {
        const { nodes } = get()
        return nodes.filter((node) => node.status === status)
      },

      extractCharacterNames: () => {
        const { nodes } = get()
        const characterSet = new Set<string>()

        nodes.forEach(node => {
          node.tags.forEach(tag => {
            if (tag.startsWith('character:')) {
              characterSet.add(tag.replace('character:', ''))
            }
          })
        })

        return Array.from(characterSet)
      },
    }))
  )
)

// Helper functions for advanced analysis
function analyzeGenreConsistency(stories: GeneratedStory[]): number {
  if (stories.length === 0) return 100
  
  const genres = stories.map(story => story.storyMetadata.genre)
  const uniqueGenres = new Set(genres)
  
  // Calculate consistency as percentage of stories sharing the most common genre
  const genreCounts = genres.reduce((counts, genre) => {
    counts[genre] = (counts[genre] || 0) + 1
    return counts
  }, {} as Record<string, number>)
  
  const maxCount = Math.max(...Object.values(genreCounts))
  return Math.round((maxCount / stories.length) * 100)
}

function analyzeCharacterPresence(stories: GeneratedStory[]): Record<string, number> {
  const characterCounts: Record<string, number> = {}
  
  stories.forEach(story => {
    story.scenes.forEach(scene => {
      // Simple character detection - could be enhanced with NLP
      const words = scene.content.toLowerCase().split(/\s+/)
      words.forEach(word => {
        if (word.length > 2 && /^[A-Z]/.test(word)) {
          characterCounts[word] = (characterCounts[word] || 0) + 1
        }
      })
    })
  })
  
  return characterCounts
}

function generateComprehensiveInsights(
  structure: StoryStructure, 
  branchAnalyses: any[], 
  generatedStories: GeneratedStory[]
): string[] {
  const insights = []
  
  // Structure insights
  if (structure.isLinear) {
    insights.push("📖 Your story follows a linear narrative structure with AI-generated content")
  } else {
    insights.push(`🌳 Your story branches into ${structure.totalBranches} different AI-enhanced narrative paths`)
  }
  
  // AI generation insights
  if (generatedStories.length > 0) {
    const totalAIWords = generatedStories.reduce((sum, story) => sum + story.wordCount, 0)
    insights.push(`✨ AI has generated ${totalAIWords} words of story content across ${generatedStories.length} narrative paths`)
    
    const averageReadingTime = generatedStories.reduce((sum, story) => sum + story.estimatedReadingTime, 0) / generatedStories.length
    insights.push(`📚 Average reading time per story branch: ${Math.round(averageReadingTime)} minutes`)
  }
  
  // Branch comparison insights
  if (branchAnalyses.length > 1) {
    insights.push(`🎭 Your alternate branches explore different narrative possibilities with AI assistance`)
  }
  
  // Orphaned nodes insight
  if (structure.orphanedNodes.length > 0) {
    insights.push(`💡 ${structure.orphanedNodes.length} scenes await connection to activate AI story generation`)
  }
  
  return insights
}

// Enhanced localStorage persistence that includes narrative intelligence data
if (typeof window !== "undefined") {
  // Subscribe to all important state changes and persist them
  useStore.subscribe(
    (state) => ({ 
      nodes: state.nodes, 
      generatedStories: state.generatedStories,
      narrativeInsights: state.narrativeInsights 
    }),
    ({ nodes, generatedStories, narrativeInsights }) => {
      try {
        localStorage.setItem("storyforge-nodes", JSON.stringify(nodes))
        localStorage.setItem("storyforge-generated-stories", JSON.stringify(generatedStories))
        localStorage.setItem("storyforge-narrative-insights", JSON.stringify(narrativeInsights))
      } catch (error) {
        console.warn('Failed to save narrative intelligence data to localStorage:', error)
      }
    },
    { fireImmediately: false }
  )

  // Subscribe to project changes
  useStore.subscribe(
    (state) => state.projects,
    (projects) => {
      try {
        localStorage.setItem("storyforge-projects", JSON.stringify(projects))
      } catch (error) {
        console.warn('Failed to save projects to localStorage:', error)
      }
    },
    { fireImmediately: false }
  )

  // Subscribe to current project changes  
  useStore.subscribe(
    (state) => state.currentProject,
    (currentProject) => {
      try {
        localStorage.setItem("storyforge-current-project", JSON.stringify(currentProject))
      } catch (error) {
        console.warn('Failed to save current project to localStorage:', error)
      }
    },
    { fireImmediately: false }
  )

  // Load all saved data on startup
  const savedNodes = localStorage.getItem("storyforge-nodes")
  const savedProjects = localStorage.getItem("storyforge-projects")
  const savedCurrentProject = localStorage.getItem("storyforge-current-project")
  const savedGeneratedStories = localStorage.getItem("storyforge-generated-stories")
  const savedNarrativeInsights = localStorage.getItem("storyforge-narrative-insights")

  if (savedNodes) {
    try {
      const nodes = JSON.parse(savedNodes)
      useStore.setState({ nodes })
      console.log('📚 Loaded nodes from localStorage:', nodes.length)
    } catch (error) {
      console.error("Failed to load saved nodes:", error)
    }
  }

  if (savedProjects) {
    try {
      const projects = JSON.parse(savedProjects)
      useStore.setState({ projects })
      console.log('📂 Loaded projects from localStorage:', projects.length)
    } catch (error) {
      console.error("Failed to load saved projects:", error)
    }
  }

  if (savedCurrentProject) {
    try {
      const currentProject = JSON.parse(savedCurrentProject)
      useStore.setState({ currentProject })
      console.log('🎯 Loaded current project from localStorage:', currentProject?.title)
    } catch (error) {
      console.error("Failed to load saved current project:", error)
    }
  }

  if (savedGeneratedStories) {
    try {
      const generatedStories = JSON.parse(savedGeneratedStories)
      useStore.setState({ generatedStories })
      console.log('📖 Loaded generated stories from localStorage:', Object.keys(generatedStories).length)
    } catch (error) {
      console.error("Failed to load saved generated stories:", error)
    }
  }

  if (savedNarrativeInsights) {
    try {
      const narrativeInsights = JSON.parse(savedNarrativeInsights)
      useStore.setState({ narrativeInsights })
      console.log('💡 Loaded narrative insights from localStorage:', narrativeInsights.length)
    } catch (error) {
      console.error("Failed to load saved narrative insights:", error)
    }
  }

  // Auto-initialize everything when the store loads
  setTimeout(() => {
    const store = useStore.getState()
    
    // Check service health
    store.checkServiceHealth()
    
    // If we have nodes and auto-generation is enabled, analyze structure
    if (store.nodes.length > 0) {
      store.analyzeStoryStructure()
      
      // If we have story structure but no generated stories, and auto-generation is enabled,
      // we might want to process the existing structure (but we'll be conservative here)
      console.log('🧠 Narrative intelligence system initialized and ready')
    }
  }, 1000)
}